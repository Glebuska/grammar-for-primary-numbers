# grammar-for-primary-numbers
Solver for primary numbers

# Задача
1. Построить машину Тьюринга (*МТ*) и линейный ограниченный автомат (*LBA*), допускающие язык **L** простых чисел в унарной системе счисления.
2. Далее:
	1. Для МТ написать транслятор в КС грамматику, которая порождает тот же язык **L**.
	2. Для LBA написать транслятор в КЗ грамматику, которая порождает тот же язык **L**.
3. Написать программу, которая принимает число, говорит простое оно или нет и выводит дерево разбора в файл **[derivation.txt]** в случае, если простое

# Решение
1. Файлы automaton.txt и automaton_lba.txt для МТ и LBA соответственно.
2. 
	1. Файл *translator.py*
	2. Файл *translator_lba.py*
3. Файл *run.py*: 

## Запуск
#### Неограниченная грамматика
```bash
pypy3 translator.py
pypy3 run.py grammar.txt <number> 
```

Вместо pypy3 можно использовать python3 (снижает производительность):

```bash
python3 translator.py
python3 run.py grammar.txt <number> 
```
#### КЗ грамматика
```bash
pypy3 translator_lba.py
pypy3 run.py grammar_lba.txt <number>
```
Далее построчно вводим числа. На каждое получим ответ **YES** и стэк в файле **derivation.txt**, если введенное слово выводимо в данной КС грамматике и **NO**, если нет.

### Вывод продукций
В файле **derivation.txt** сохраняется последний удачный вывод простого числа в следующем виде:
каждая строка - состояние ленты перед применением одной продукции. 

Начальная строка представляет заданное слово на ленте (со всеми спец символами). Далее следует последовательное применение продукций, пока не достигнется финальное состояние (**finish** или **qaccept**), и последующий привод ленты к исходному числу.

Последняя строка состоит из терминалов, представляя заданное простое число

Обратите внимание, что для грамматики типа 1 число представляется в унарной системе счисления над алфавитом {*a*}, а для грамматики типа 0 -> {*1*}.

Также обращаем внимание на то, что символ **'[a, a]'** на ленте представляет одну букву *a* (одну единицу), а **'[1, 1]'** - одну единицу соответственно.
#### Пример вывода простого числа 3 из Т1
```bash
'[q1.0, #, a, a]', '[a, a]', '[a, a, #]'
'[#, q1.0, a, a]', '[a, a]', '[a, a, #]'
'[#, I, a]', '[q1.1, a, a]', '[a, a, #]'
'[#, I, a]', '[I, a]', '[q1.2, a, a, #]'
'[#, I, a]', '[q1.3, I, a]', '[a, a, #]'
'[#, q1.3, I, a]', '[I, a]', '[a, a, #]'
...
'[#, i, a]', '[I, a]', '[q2.1.2, I, a, #]'
'[#, i, a]', '[I, a]', '[I, a, q2.1.2, #]'
'[#, i, a]', '[I, a]', '[qaccept, I, a, #]'
'[#, i, a]', '[I, a]', 'a'
'[#, i, a]', 'a', 'a'
'a', 'a', 'a'
```

#### Пример вывода простого числа 3 из Т0
```bash
'[, _]', '[, _]', '[, _]', '[, _]', '[, _]', 'q00', '[1, 1]', '[1, 1]', '[1, 1]', '[, _]', '[, _]', '[, _]', '[, _]', '[, _]'
'[, _]', '[, _]', '[, _]', '[, _]', 'q01', '[, _]', '[1, 1]', '[1, 1]', '[1, 1]', '[, _]', '[, _]', '[, _]', '[, _]', '[, _]'
'[, _]', '[, _]', '[, _]', '[, _]', '[, #]', 'q0', '[1, 1]', '[1, 1]', '[1, 1]', '[, _]', '[, _]', '[, _]', '[, _]', '[, _]'
'[, _]', '[, _]', '[, _]', '[, _]', '[, #]', '[1, 1]', 'q1', '[1, 1]', '[1, 1]', '[, _]', '[, _]', '[, _]', '[, _]', '[, _]'
...
'[, _]', '[, 1]', '1', '1', '1'
'[, _]', 'finish', '1', '1', '1'
'[, _]', '1', '1', '1'
'finish', '1', '1', '1'
'1', '1', '1'
```